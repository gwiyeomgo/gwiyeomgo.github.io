"use strict";(self.webpackChunkgwiyeom_blog=self.webpackChunkgwiyeom_blog||[]).push([[933],{2618:function(e,l,n){n.r(l),n.d(l,{Head:function(){return u.p},default:function(){return E}});var t=n(6540),r=n(8453);function a(e){const l=Object.assign({h1:"h1",p:"p",pre:"pre",code:"code",ol:"ol",li:"li",blockquote:"blockquote",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",ul:"ul"},(0,r.RP)(),e.components);return t.createElement(t.Fragment,null,t.createElement(l.h1,null,"배경"),"\n",t.createElement(l.p,null,"5초 이상 속도 지연되면 알림이 온다\n자주 오는 알림중 업무 목록 API 속도를 개선하려고 한다"),"\n",t.createElement(l.p,null,"아래 쿼리는 직원의 업무 목록을 조회하는 API 에서 속도를 지연시키는 쿼리였다"),"\n",t.createElement(l.pre,null,t.createElement(l.code,null,"SELECT * FROM A\nINNER JOIN B ON A.donation_id = B.id\nLEFT JOIN C ON B.id = C.donation_id and C.deleted_at is null\n WHERE (A.deleted_at is null) AND (B.deleted_at is null)\n AND (A.status='Register')\n AND ((A.out_id IN (\"31231.2323\",\"12412.4124\" ..... ) OR member_id = 655)\n AND (A.date < '20250418')\n AND (A.deleted_at IS NULL OR A.deleted_at='0001-01-01 00:00:00');\n\n")),"\n",t.createElement(l.h1,null,"분석"),"\n",t.createElement(l.ol,null,"\n",t.createElement(l.li,null,"\n",t.createElement(l.p,null,"로그를 통해 쿼리를 확인하니\nWHERE 절 out_id  IN 조건 값이 너무 많았다 (인덱스 타지 않음)"),"\n"),"\n",t.createElement(l.li,null,"\n",t.createElement(l.p,null,"EXPLAIN 실행하니 인덱스는 2개 있지만\ncollects 테이블에서 type ALL 으로 전체 스캔 하고 있으며 rows 92563건으로 많다\nUsing where 로 WHERE 조건으로 필터링중"),"\n"),"\n"),"\n",t.createElement(l.h1,null,"개선 작업"),"\n",t.createElement(l.ol,null,"\n",t.createElement(l.li,null,"donation_collects 테이블의 WHERE 조건들이 인덱스를 타도록 설계","\n",t.createElement(l.ol,null,"\n",t.createElement(l.li,null,"out_id 인덱스 추가 -> 변화 X"),"\n",t.createElement(l.li,null,"여러 조건으로 복합인덱스를 추가해서 개발환경에서 확인했지만 효과 없고 사용 안함\n복합 인덱스(member_id, date, deleted_at)는 추가됐지만 사용되지 않음"),"\n"),"\n"),"\n"),"\n",t.createElement(l.h1,null,"왜 인덱스를 안타지?"),"\n",t.createElement(l.ol,null,"\n",t.createElement(l.li,null,"MySQL 옵티마이저는 성능이 인덱스보다 풀 스캔이 빠르다고 판단하면 인덱스를 안탄다?\nIN (1,2,3,...,10000) 식으로 값이 매우 많을 경우, 인덱스를 포기"),"\n",t.createElement(l.li,null,"OR 조건 또는 복잡한 조건 조합\n",t.createElement(l.code,null,'AND ((A.out_id IN ("31231.2323","12412.4124" ..... ) OR member_id = 655)'),"\nOR을 사용\n(A AND B) OR (C AND D) 처럼 조건 분기가 생기면 인덱스를 못 타는 경우가 생김"),"\n"),"\n",t.createElement(l.h1,null,"작업 내용"),"\n",t.createElement(l.ol,null,"\n",t.createElement(l.li,null,"OR → UNION ALL 방식으로 쿼리 분해 +  기존 기능 동작하는지 테스트"),"\n",t.createElement(l.li,null,"IN 리스트 대신 가상 테이블 조인 고려 (WITH)  +  기존 기능 동작하는지 테스트"),"\n",t.createElement(l.li,null,"복합 인덱스를 조건 순서대로 만들고"),"\n"),"\n",t.createElement(l.h1,null,"개선 전 후 결과 기록"),"\n",t.createElement(l.blockquote,null,"\n",t.createElement(l.p,null,"1번 결과\n|쿼리 | select_type | table | type | key | rows | Extra|\n|---|---|---|\t---|\t---|---|\t---|\n|기존  | SIMPLE | A | ALL | 여러 인덱스 중 하나 (복합 포함) | 897 | Using where |"),"\n"),"\n",t.createElement(l.p,null,"-> type ALL, 테스트 환경 데이터인데도 row 897"),"\n",t.createElement(l.table,null,t.createElement(l.thead,null,t.createElement(l.tr,null,t.createElement(l.th,null,"항목"),t.createElement(l.th,null,"기존 쿼리"),t.createElement(l.th,null,"개선 쿼리 (UNION)"))),t.createElement(l.tbody,null,t.createElement(l.tr,null,t.createElement(l.td,null,"type"),t.createElement(l.td,null,"ALL"),t.createElement(l.td,null,"ALL")),t.createElement(l.tr,null,t.createElement(l.td,null,"rows"),t.createElement(l.td,null,"약 897"),t.createElement(l.td,null,"약 897 * 2")),t.createElement(l.tr,null,t.createElement(l.td,null,"개선 여부"),t.createElement(l.td,null,"효과 없음 (풀 스캔 유지)"),t.createElement(l.td,null,"인덱스 전략 변화 없음, row 수만 증가함")))),"\n",t.createElement(l.p,null,"-> UNION으로 바꾸는 것만으로는 성능 향상이 없고 오히려 row 수가 2배...더 안좋아 진것 같음"),"\n",t.createElement(l.blockquote,null,"\n",t.createElement(l.p,null,"2번 결과"),"\n"),"\n",t.createElement(l.pre,null,t.createElement(l.code,null,'WITH out_ids(id) AS (\n  SELECT "31231.2323" UNION ALL\n  SELECT "31231.2223" UNION ALL\n  ...\n)\nSELECT ...\nFROM out_id dc\nINNER JOIN out_ids gi ON dc.out_id = gi.id\n')),"\n",t.createElement(l.table,null,t.createElement(l.thead,null,t.createElement(l.tr,null,t.createElement(l.th,null,"table"),t.createElement(l.th,null,"type"),t.createElement(l.th,null,"key"),t.createElement(l.th,null,"rows"),t.createElement(l.th,null,"Extra"))),t.createElement(l.tbody,null,t.createElement(l.tr,null,t.createElement(l.td,null,"CTE"),t.createElement(l.td,null,"ALL"),t.createElement(l.td,null,"NULL"),t.createElement(l.td,null,"330"),t.createElement(l.td,null,"CTE는 가볍고 작은 테이블처럼 처리됨")),t.createElement(l.tr,null,t.createElement(l.td,null,"A"),t.createElement(l.td,null,"ref"),t.createElement(l.td,null,"idx_A_out_id"),t.createElement(l.td,null,"402"),t.createElement(l.td,null,"Using index condition; Using where")))),"\n",t.createElement(l.h1,null,"INDEX 확인 방법"),"\n",t.createElement(l.p,null,"*",t.createElement(l.code,null,"SHOW INDEX FROM A")," 인덱스 사용"),"\n",t.createElement(l.h1,null,"결론"),"\n",t.createElement(l.p,null,"단순한 인덱스 추가만으로는 해결이 어려운 케이스로\nWITH + JOIN 방식이 효과적으로 인덱스 활용을 유도함"),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,"기존의 330 rows만 읽음"),"\n",t.createElement(l.li,null,"EXPLAIN type ALL -> Ref"),"\n",t.createElement(l.li,null,"실행 계획: Using index condition; Using where 확인"),"\n"))}var c=function(e){void 0===e&&(e={});const{wrapper:l}=Object.assign({},(0,r.RP)(),e.components);return l?t.createElement(l,e,t.createElement(a,e)):a(e)},u=n(7292);function E(e){return t.createElement(u.A,e,t.createElement(c,e))}u.A}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-server-database-mysql-2025-04-03-mysql-optimized-task-api-mdx-cc0e2305055436b1ff1a.js.map