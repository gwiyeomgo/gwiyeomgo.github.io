"use strict";(self.webpackChunkgwiyeom_blog=self.webpackChunkgwiyeom_blog||[]).push([[4130],{7911:function(e,t,n){n.r(t),n.d(t,{Head:function(){return E.p},default:function(){return u}});var l=n(6540),r=n(8453);function a(e){const t=Object.assign({h1:"h1",p:"p",pre:"pre",code:"code",ol:"ol",li:"li",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,r.RP)(),e.components);return l.createElement(l.Fragment,null,l.createElement(t.h1,null,"배경"),"\n",l.createElement(t.p,null,"수거 업무 목록에서 여전히 5초 알림이 계속 발생하고 있다\n쿼리,인덱스 추가 를 계속 했지만"),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"WITH out_ids AS (\n  SELECT id FROM ...\n)\nSELECT ...\nFROM data\nJOIN out_ids ON ...\n")),"\n",l.createElement(t.p,null,"CTE 임시 테이블안에 데이터가 계속 늘어날수록\n반복 루프마다 CTE를 실행했고\n300개 이상 row를 계속 다시 읽는 현상이 발생했다\n쿼리를 계속 조건을 주석하며 쿼리 플랜을 보니\ndate 값의 시작 날짜를 지정했더니\n속도도 빨라지고 성능이 좋아졌다"),"\n",l.createElement(t.h1,null,"쿼리플랜 비교"),"\n",l.createElement(t.p,null,"🔴 변경 전\ndate < '20250521'만 조회\ndata 인덱스가 넓은 범위 조회\n→ result rows 11"),"\n",l.createElement(t.p,null,"이로 인해\nmember 조인 루프: 11번\nevent 조인 루프: 7번\nout_ids 조인 루프: 7번\n문제는 이때 CTE도 7번 materialize됨 매우 비효율적"),"\n",l.createElement(t.p,null,"🟢 변경 후\ndate > '20250101' AND date < '20250521'로 범위를 좁힘\n→ result rows 2"),"\n",l.createElement(t.p,null,"member 조인 루프: 2번\nevent 조인 루프: 2번\nout_ids 조인 루프: 2번\nCTE는 1회 materialize 후 재사용됨"),"\n",l.createElement(t.h1,null,"CTE materialize (구체화) 뭔데?"),"\n",l.createElement(t.p,null,"CTE는 WITH로 정의한 서브쿼리인데\nMySQL 8.0+ 에서는 CTE를 실제로 한 번만 실행해서 결과를 임시 테이블처럼 메모리에 저장한다\n이걸 CTE materialize (구체화)라고 하는데.."),"\n",l.createElement(t.h1,null,"문제 상황"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"불필요한 row 탐색 줄이기\n데이터가 늘어날수로 검색하는 row 수가 많아졌음\n필요 이상으로 CTE를 루프마다 재실행 발생으로\nCTE가 매 루프마다 다시 materialize되었는데\n날짜 범위를 좁힘으로써 조인 대상이 줄어들었고\nCTE와의 조인 횟수도 줄어들었다"),"\n",l.createElement(t.li,null,"Nested Loop 반복 최소화\n데이터가 늘어날수로 Nested Loop 루프 수도 계속 늘어남\n외부 테이블의 각 row에 대해 내부 테이블을 반복 탐색합\n외부 row가 많을수록 내부 테이블 탐색 횟수가 기하급수적으로 증가"),"\n",l.createElement(t.li,null,"Nested Loop 증거로 CTE Materialize 계속 반복\n검색 범위를 명확히 지정했더니 조인 루프 횟수 감소했고\nMySQL은 기본적으로 CTE materialization을 최적화하려 하지만\n루프 가 많아지면서 매번 다시 읽어오는 방식으로 변경되어 느려졌었다"),"\n"),"\n",l.createElement(t.table,null,l.createElement(t.thead,null,l.createElement(t.tr,null,l.createElement(t.th,null,"항목"),l.createElement(t.th,null,"변경 전"),l.createElement(t.th,null,"변경 후"))),l.createElement(t.tbody,null,l.createElement(t.tr,null,l.createElement(t.td,null,"Index Scan 범위"),l.createElement(t.td,null,"넓음 (상한만 있음)"),l.createElement(t.td,null,"좁음 (상하한 지정)")),l.createElement(t.tr,null,l.createElement(t.td,null,l.createElement(t.code,null,"data")," rows"),l.createElement(t.td,null,"11건"),l.createElement(t.td,null,"2건")),l.createElement(t.tr,null,l.createElement(t.td,null,"Nested Loop 반복"),l.createElement(t.td,null,"11회 이상"),l.createElement(t.td,null,"2회")),l.createElement(t.tr,null,l.createElement(t.td,null,"CTE Materialize 접근"),l.createElement(t.td,null,"최대 수백 회"),l.createElement(t.td,null,"단 1회")),l.createElement(t.tr,null,l.createElement(t.td,null,"쿼리 실행 시간"),l.createElement(t.td,null,"비슷 (데이터 적음)"),l.createElement(t.td,null,"비슷하지만 훨씬 가볍게 작동")))),"\n",l.createElement(t.p,null,"date 조건 범위를 명확히 지정하여\n불필요한 데이터 스캔과 반복 조인 횟수를 최소화했고\nCTE 처리 비용을 줄임으로써 대규모 데이터에서도 확장 가능한 구조로 개선"))}var c=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,r.RP)(),e.components);return t?l.createElement(t,e,l.createElement(a,e)):a(e)},E=n(7292);function u(e){return l.createElement(E.A,e,l.createElement(c,e))}E.A}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-server-database-mysql-2025-05-21-mysql-cte-materialize-mdx-120fd59db56d617811cf.js.map