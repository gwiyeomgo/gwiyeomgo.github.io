"use strict";(self.webpackChunkgwiyeom_blog=self.webpackChunkgwiyeom_blog||[]).push([[5636],{1475:function(e,n,t){t.r(n),t.d(n,{Head:function(){return o.F},default:function(){return s}});var r=t(7294),a=t(1151);function l(e){const n=Object.assign({h3:"h3",ul:"ul",li:"li",p:"p",h1:"h1",ol:"ol",blockquote:"blockquote",pre:"pre",code:"code"},(0,a.ah)(),e.components);return r.createElement(r.Fragment,null,r.createElement(n.h3,null,"async  await"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"es2017 도입"),"\n",r.createElement(n.li,null,"프라미스 기반의 비동기 코드를 동기적 코드처럼 작성 할 수 있게 합니다."),"\n",r.createElement(n.li,null,"await 키워드는 async 키워드로 선언된 함수 안에서만 사용"),"\n"),"\n",r.createElement(n.h3,null,"에러"),"\n",r.createElement(n.p,null,"UnhandledPromiseRejection\r\n에러 메세지 확인"),"\n",r.createElement(n.h1,null,"찾아보니"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"asnyc/await을 사용한 함수는 promise를 반환한다는 것을 알게되었다."),"\n",r.createElement(n.li,null,"async 키워드를 사용한 함수의 경우\r\ntry "," catch"," 로 애러 핸들안해줘서 발생"),"\n"),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"then/catch 사용"),"\n"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"axios.get('https://api.test.com/data').then((response) => {\r\n  if (response && response.data){\r\n   axios.getget('https://api.test2.com/data').then((res) => {\r\n       setData({\r\n        classification:res.data,\r\n        donation:response.data\r\n        });\r\n    });\r\n  }\r\n})\n")),"\n",r.createElement(n.p,null,"then/catch는 프로미스 체이닝을 사용해서\r\n순차적으로 비동기 작업을 수정할 수 있습니다\r\n첫 요청이 성공하면 다음 요청을 수행"),"\n",r.createElement(n.blockquote,null,"\n",r.createElement(n.p,null,"async/await 사용"),"\n"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"const load =  async () => {\r\n\r\n  try {\r\n    const response = await axios.get('https://api.test.com/data');\r\n    if (response && response.data) {\r\n      const res = await axios.get('https://api.test2.com/data');\r\n      setData({\r\n        classification: res.data,\r\n        donation: response.data\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error('Error fetching data:', error);\r\n  }\r\n};\n")),"\n",r.createElement(n.p,null,"async/await는 비동기 코드를 동기 코드처럼 작성할 수 있어서 직관적\r\nawait 을 사용해 프로미스가 해결될 때까지 기다리며\r\ntry catch 로 블록을 사용해 에러처리\r\nasync/await 디버깅시 스택 트레이스 제공"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"async/await 와 then/catch 혼합해서 사용 비추"),"\n"),"\n",r.createElement(n.pre,null,r.createElement(n.code,null,"const load = async () => {\r\n  try {\r\n    const response = await axios.get('https://api.test.com/data')\r\n      .then(response => {\r\n        // .then 블록 안에서 또 다른 비동기 요청을 처리\r\n        return axios.get('https://api.test2.com/data').then(res => {\r\n          setData({\r\n            classification: res.data,\r\n            donation: response.data\r\n          });\r\n          return res;\r\n        });\r\n      });\r\n  } catch (error) {\r\n    console.error('Error fetching data:', error);\r\n  }\r\n};\n")),"\n",r.createElement(n.p,null,"await 사용시\r\n비동기 작업을 동기적으로 작성할 수 있어서\r\n마치 동기 코드처럼 보입니다"),"\n",r.createElement(n.p,null,"반면 then 은 비동기 체이닝을 사용한 구문입니다"),"\n",r.createElement(n.p,null,"해당 부분이 코드를 읽는 사람이 혼란스러울 수 있습니다.\r\n두가지 비동기 처리 방식을 이해하고 신경 써야 하기 때문에 가독성을 떨어뜨립니다\r\ntry catch 와 then 이후 catch 등 중복 사용된다면 정확히 어디서 에러가 처리되는지 알 수 없습니다"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"try...catch...finally"),"\n"),"\n",r.createElement(n.p,null,"--\x3e async/await와 try...catch...finally를 사용하는 것이 더 적합"),"\n",r.createElement(n.p,null,"예외 상황 처리 (try...catch):"),"\n",r.createElement(n.p,null,"try...catch 블록을 사용하면 코드 실행 중 발생하는 예외(오류)를 즉시 감지하고 처리할 수 있습니다.\r\n만약 DonationCollectService.updateCollectDonation나 DonationService.registerDonation 호출 중에 예기치 않은 오류가 발생하더라도, catch 블록에서 이를 잡아내어 처리할 수 있습니다.\r\n이를 통해, 오류가 발생했을 때 코드가 중간에 멈추는 것을 방지하고, 이후의 로직을 정상적으로 처리할 수 있게 됩니다.\r\n후속 작업 보장 (finally):"),"\n",r.createElement(n.p,null,"finally 블록은 try 블록에서 예외가 발생하든 그렇지 않든, 무조건 실행됩니다.\r\n이 블록을 통해, 비동기 작업의 성공 여부와 관계없이 setLoading(false), reset(), onClose(), reload()와 같은 후속 작업이 반드시 실행됩니다.\r\n따라서, 예외가 발생해도 로딩 상태 해제나 폼 리셋 등 중요한 후속 작업이 누락되지 않고, UI가 안정적으로 유지됩니다.\r\n유효성 검사 오류 예방:"),"\n",r.createElement(n.p,null,"예외 상황이 적절히 처리되지 않으면 예상치 못한 데이터 상태가 발생할 수 있으며, 이는 유효성 검사 라이브러리(async-validator)에서 오류로 이어질 수 있습니다.\r\ntry...catch...finally를 통해 비정상적인 데이터 상태를 초래할 수 있는 예외 상황을 예방하고, 안정적인 데이터 처리를 보장함으로써 유효성 검사 오류가 발생할 가능성을 줄였습니다."))}var c=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?r.createElement(n,e,r.createElement(l,e)):l(e)},o=t(8804);function s(e){return r.createElement(o.Z,e,r.createElement(c,e))}o.Z}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-client-javascript-2022-04-11-javascript-async-await-mdx-02be09d0baa307e1f8e3.js.map