"use strict";(self.webpackChunkgwiyeom_blog=self.webpackChunkgwiyeom_blog||[]).push([[5524],{1703:function(e,l,n){n.r(l),n.d(l,{Head:function(){return u.p},default:function(){return a}});var t=n(6540),c=n(8453);function r(e){const l=Object.assign({p:"p",h4:"h4",strong:"strong",ul:"ul",li:"li",code:"code",hr:"hr"},(0,c.RP)(),e.components);return t.createElement(t.Fragment,null,t.createElement(l.p,null,"EXPLAIN 으로 실행계획 볼때 기억해야할 것들 정리"),"\n",t.createElement(l.h4,null,t.createElement(l.strong,null,"0. 기본적인 실행 계획 관련 문장")),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,t.createElement(l.code,null,"EXPLAIN"),"을 사용하여 쿼리 실행 계획을 분석할 수 있습니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"type = ALL"),": 테이블을 전체 스캔하므로 성능이 저하될 수 있습니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"type = const"),": ",t.createElement(l.strong,null,"주어진 값 하나만 조회하는 경우"),"로, 가장 빠른 방식 중 하나입니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"type = range"),": ",t.createElement(l.strong,null,"인덱스를 활용한 범위 검색"),"으로, 성능이 우수합니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"type = index"),": ",t.createElement(l.strong,null,"테이블 전체를 인덱스만을 통해 스캔"),"하는 방식으로, 필요하지 않다면 피하는 것이 좋습니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"key"),": ",t.createElement(l.strong,null,"실제로 사용된 인덱스를 나타내며"),", 효율성을 평가할 수 있습니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"rows"),": ",t.createElement(l.strong,null,"쿼리 실행 시 스캔해야 할 행의 개수"),"를 의미하며, 값이 적을수록 성능이 좋습니다. 값이 크다면 적절한 인덱스를 추가하는 것이 필요할 수 있습니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"Using index"),": ",t.createElement(l.strong,null,"커버링 인덱스를 사용하여 테이블 접근 없이 데이터를 조회하는 방식"),"으로, 효율적입니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"Using where"),": ",t.createElement(l.strong,null,"인덱스를 사용했지만 추가적인 필터링이 필요한 경우"),"에 나타납니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"Using temporary")," / ",t.createElement(l.code,null,"Using filesort"),": ",t.createElement(l.strong,null,"임시 테이블 및 파일 정렬이 발생하면 성능 저하의 원인이 될 수 있으므로 피하는 것이 좋습니다.")),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"key_len"),": ",t.createElement(l.strong,null,"사용된 인덱스의 길이"),"를 나타내며, 값이 짧을수록 인덱스 활용이 효율적입니다."),"\n"),"\n",t.createElement(l.hr),"\n",t.createElement(l.h4,null,t.createElement(l.strong,null,"1. 쿼리 최적화 및 성능 개선")),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,t.createElement(l.code,null,"EXPLAIN"),"을 사용하여 쿼리 실행 계획을 분석하고, ",t.createElement(l.code,null,"type"),", ",t.createElement(l.code,null,"key"),", ",t.createElement(l.code,null,"rows")," 등의 정보를 확인하여 성능을 최적화합니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"EXPLAIN ANALYZE"),"를 활용하면 실제 실행 시간과 행(row) 처리 개수를 확인할 수 있습니다."),"\n",t.createElement(l.li,null,"불필요한 서브쿼리는 조인으로 대체하는 것이 성능에 유리합니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"WHERE")," 절에서 불필요한 조건을 제외하고, 인덱스를 활용할 수 있도록 작성하면 성능이 향상됩니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"ORDER BY"),"와 ",t.createElement(l.code,null,"GROUP BY"),"는 성능에 영향을 줄 수 있으므로, 필요할 경우 적절한 인덱스를 추가해야 합니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"HAVING")," 절은 ",t.createElement(l.code,null,"GROUP BY")," 이후에 실행되므로, 필터링이 가능한 경우 ",t.createElement(l.code,null,"WHERE")," 절에서 처리하는 것이 좋습니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"COUNT(*)"),"는 인덱스를 활용하여 최적화할 수 있습니다(예: ",t.createElement(l.code,null,"COUNT(인덱스_컬럼)"),")."),"\n"),"\n",t.createElement(l.hr),"\n",t.createElement(l.h4,null,t.createElement(l.strong,null,"2. 인덱스 활용 및 조인 최적화")),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,t.createElement(l.code,null,"eq_ref"),": ",t.createElement(l.strong,null,"가장 빠른 조인 방식으로, 조인된 각 행에 대해 정확히 하나의 행을 찾는 방식"),"입니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"ref"),": ",t.createElement(l.strong,null,"조인 시 인덱스를 사용하여 레코드를 빠르게 찾을 수 있는 방식"),"입니다."),"\n",t.createElement(l.li,null,"두 테이블의 조인 키가 적절한 인덱스를 사용하지 않으면 성능이 저하될 수 있습니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"INNER JOIN"),"은 필요하지 않은 데이터를 제외하여 성능을 최적화할 수 있습니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"LEFT JOIN"),"을 사용할 때 ",t.createElement(l.strong,null,"가능하다면 ",t.createElement(l.code,null,"INNER JOIN"),"을 고려하는 것이 성능상 유리할 수 있습니다.")),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"ON")," 절과 ",t.createElement(l.code,null,"USING")," 절을 적절히 사용하면 조인의 가독성과 성능을 향상할 수 있습니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"NATURAL JOIN"),"은 공통 컬럼을 기준으로 자동 조인되지만, 명확한 컬럼 지정이 어렵기 때문에 권장되지 않습니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"EXPLAIN"),"을 사용하여 ",t.createElement(l.code,null,"JOIN")," 시 ",t.createElement(l.code,null,"Using index"),"가 나타나는지 확인하고, 필요한 경우 인덱스를 추가하여 성능을 개선할 수 있습니다."),"\n",t.createElement(l.li,null,"WHERE 절에서 ",t.createElement(l.strong,null,"인덱스의 첫 번째 컬럼을 정확히 지정하면 복합 인덱스를 효율적으로 활용할 수 있습니다.")),"\n",t.createElement(l.li,null,"복합 인덱스의 모든 컬럼을 정확한 값으로 조회하면 ",t.createElement(l.code,null,"const")," 타입이 나타나며, 최적화됩니다."),"\n",t.createElement(l.li,null,"단일 인덱스보다는 복합 인덱스를 사용하는 것이 여러 조건을 결합한 조회에서 유리할 수 있습니다."),"\n"),"\n",t.createElement(l.hr),"\n",t.createElement(l.h4,null,t.createElement(l.strong,null,"3. 서브쿼리 및 필터링 최적화")),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,t.createElement(l.strong,null,"복잡한 서브쿼리는 성능을 저하시킬 수 있으므로, 가능하면 조인으로 변환하는 것이 좋습니다.")),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"WHERE")," 절에서 ",t.createElement(l.code,null,"!=")," 연산자는 인덱스를 비효율적으로 만들 수 있습니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"IN")," 절은 작은 범위의 값에 대해서는 효과적이지만, 너무 많은 값을 포함하면 성능이 저하될 수 있습니다."),"\n",t.createElement(l.li,null,"서브쿼리 대신 ",t.createElement(l.strong,null,"JOIN을 활용하면 성능을 개선할 수 있습니다.")),"\n"),"\n",t.createElement(l.hr),"\n",t.createElement(l.h4,null,t.createElement(l.strong,null,"4. 데이터 조회 및 정렬 최적화")),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,t.createElement(l.code,null,"SELECT *")," 대신 ",t.createElement(l.strong,null,"필요한 컬럼만 조회하면 불필요한 데이터 로딩을 방지할 수 있습니다.")),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"DISTINCT"),"는 중복 제거를 위해 추가적인 정렬 연산이 필요하므로 꼭 필요한 경우에만 사용합니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"LIKE '%값'"),"(앞부분이 와일드카드인 경우)은 ",t.createElement(l.strong,null,"인덱스를 사용할 수 없어 성능이 저하될 수 있습니다.")),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"GROUP BY"),"와 ",t.createElement(l.code,null,"ORDER BY"),"를 함께 사용할 때, ",t.createElement(l.strong,null,"인덱스를 활용하면 성능을 향상시킬 수 있습니다.")),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"LIMIT"),"을 사용하면 불필요한 데이터를 줄여 성능을 개선할 수 있습니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"UNION")," 대신 ",t.createElement(l.code,null,"UNION ALL"),"을 사용하면 ",t.createElement(l.strong,null,"중복 제거 연산을 생략하여 성능이 향상될 수 있습니다.")),"\n"),"\n",t.createElement(l.hr),"\n",t.createElement(l.h4,null,t.createElement(l.strong,null,"5. 대량 데이터 처리 및 삽입 최적화")),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,"대량 데이터 삽입 시 ",t.createElement(l.strong,null,t.createElement(l.code,null,"INSERT INTO SELECT")," 문을 활용하면 성능이 향상될 수 있습니다.")),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"LIMIT"),"을 사용하여 필요한 데이터만 조회하면 성능이 향상될 수 있습니다."),"\n",t.createElement(l.li,null,"대량 삽입 시 트랜잭션을 사용하여 한 번에 처리하면 성능이 개선될 수 있습니다."),"\n",t.createElement(l.li,null,t.createElement(l.strong,null,"여러 개의 ",t.createElement(l.code,null,"INSERT")," 문 대신, ",t.createElement(l.code,null,"BULK INSERT")," 또는 ",t.createElement(l.code,null,"INSERT ... VALUES (...), (...), (...)")," 문을 사용하는 것이 더 효율적입니다.")),"\n"),"\n",t.createElement(l.hr),"\n",t.createElement(l.h4,null,t.createElement(l.strong,null,"6. 연산자 및 조건문 최적화")),"\n",t.createElement(l.ul,null,"\n",t.createElement(l.li,null,t.createElement(l.code,null,"OR")," 연산자는 인덱스를 활용하지 못할 수 있으므로, ",t.createElement(l.strong,null,"가능하면 ",t.createElement(l.code,null,"UNION ALL")," 또는 별도 조건을 분리하는 것이 성능에 유리할 수 있습니다.")),"\n",t.createElement(l.li,null,"복잡한 ",t.createElement(l.code,null,"CASE WHEN")," 문을 단순화하면 쿼리 성능이 개선될 수 있습니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"BETWEEN")," 연산자는 범위 조건을 설정할 때 인덱스를 효율적으로 사용할 수 있습니다."),"\n",t.createElement(l.li,null,t.createElement(l.code,null,"EXPLAIN"),"을 사용하여 ",t.createElement(l.code,null,"filesort")," 또는 ",t.createElement(l.code,null,"temporary"),"가 발생하는지 확인하고, 인덱스를 활용하여 최적화하는 것이 좋습니다."),"\n"),"\n",t.createElement(l.hr))}var E=function(e){void 0===e&&(e={});const{wrapper:l}=Object.assign({},(0,c.RP)(),e.components);return l?t.createElement(l,e,t.createElement(r,e)):r(e)},u=n(7292);function a(e){return t.createElement(u.A,e,t.createElement(E,e))}u.A}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-server-database-mysql-2025-03-26-mysql-explain-mdx-a47b8580e66efa4a2c03.js.map