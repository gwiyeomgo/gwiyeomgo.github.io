"use strict";(self.webpackChunkgwiyeom_blog=self.webpackChunkgwiyeom_blog||[]).push([[6865],{6406:function(e,n,t){t.r(n),t.d(n,{Head:function(){return a.p},default:function(){return u}});var l=t(6540),r=t(8453);function o(e){const n=Object.assign({h1:"h1",p:"p",code:"code",pre:"pre",ol:"ol",li:"li",blockquote:"blockquote",ul:"ul",h3:"h3"},(0,r.RP)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.h1,null,"배경"),"\n",l.createElement(n.p,null,"route53에 도메인을 등록했다\n1.호스팅 영역> 기존 gwiyoem.org 도메인선택\n2.레코드 생성\n",l.createElement(n.code,null,"새 서브도메인 (예: test-service.gwiyeom.org) → EC2 퍼블릭 IP로 연결")),"\n",l.createElement(n.p,null,"이후 postman 으로 호출했지만 404 에러가 발생했다"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"<html>\n<head><title>404 Not Found</title></head>\n<body>\n<center><h1>404 Not Found</h1></center>\n<hr><center>nginx/1.18.0 (Ubuntu)</center>\n</body>\n</html>\n\n")),"\n",l.createElement(n.p,null,"EC2에서 Nginx 실행 중 인데\nEC2 안의 Nginx가 새 도메인을 처리하지 못해서 발생했다"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"\nPostman or 브라우저\n        ↓\nRoute53 (도메인 네임서버)\n    ↓\n도메인이 연결된 IP (예: EC2 퍼블릭 IP)\n    ↓\nEC2 인스턴스 내 Nginx\n    ↓\nNginx가 백엔드 앱 (예: Golang, Node 등)으로 요청 전달\n\n")),"\n",l.createElement(n.h1,null,"Nginx가 뭐고 왜 도메인을 지정해야하지?"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"Nginx = 웹 서버이자 리버스 프록시 서버 = 안내 데스크\n요청을 받아서 적절한 서버(앱)로 전달해주는 배달원"),"\n"),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,l.createElement(n.code,null,"https://test-service.gwiy eom.org"),' 요청-> 서버(EC2) 도착하면 Nginx 가 "이 요청은 NestJS 서버로 보내야겠군~" 하면서\nlocalhost:3000 로 전달 = 리버스 프록시'),"\n"),"\n",l.createElement(n.ol,{start:"2"},"\n",l.createElement(n.li,null,"서버(EC2)에 도착했을 때 Nginx가 어떻게 처리할지 알려주기 위해!\n어떤 요청을 어떤 앱에 연결해줘야 하는지 알기 위해 서브 도메인 등록 필요"),"\n"),"\n",l.createElement(n.h1,null,"Nginx에 서브도메인 등록하는 방법"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"Nginx 설정 파일에 문법 오류가 있는지 검사하는 명령어\n",l.createElement(n.code,null,"sudo nginx -t")),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"nginx: the configuration file /etc/nginx/nginx.conf syntax is ok\nnginx: configuration file /etc/nginx/nginx.conf test is successful\n")),"\n",l.createElement(n.ol,{start:"2"},"\n",l.createElement(n.li,null,"파일열기\n",l.createElement(n.code,null,"sudo nano /etc/nginx/nginx.conf"),"\n파일이 없는 상황 ㅠ"),"\n",l.createElement(n.li,null,"default만 사용중으로 확인됨!\n",l.createElement(n.code,null,"ls /etc/nginx/sites-available")),"\n"),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"default  default.bak"),"\n"),"\n",l.createElement(n.p,null,"default 파일 열기\n",l.createElement(n.code,null,"sudo nano /etc/nginx/sites-available/default")),"\n",l.createElement(n.ol,{start:"4"},"\n",l.createElement(n.li,null,"편집\nNginx 서버 설정에 test-service.gwiyeom.org라는 서브도메인을 추가\nCertbot으로 HTTPS 인증서를 설정 을 위한 값 추가"),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"# 서브도메인을 추가\nserver {\n    server_name test-service.gwiyeom.org;\n    location / {\n        proxy_pass http://127.0.0.1:4000;\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Forwarded-Host $http_host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n\n#\nserver {\n    if ($host = test-service.gwiyeom.org) {\n        return 301 https://$host$request_uri;\n    } # managed by Certbot\n\n  server_name test-service.gwiyeom.org;\n    listen 80;\n    return 404; # managed by Certbot\n}\n")),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Let's Encrypt(Certbot)를 이용해 HTTPS 인증서를 발급받고,HTTP 요청은 HTTPS로 리디렉션 처리하는 것."),"\n"),"\n",l.createElement(n.p,null,"Ctrl + O → 저장\nEnter → 파일 이름 확인하고 저장\nCtrl + X → 종료"),"\n",l.createElement(n.ol,{start:"5"},"\n",l.createElement(n.li,null,"nginx에 적용"),"\n"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Nginx 설정 파일에 문법 오류가 있는지 검사하는 명령어 ",l.createElement(n.code,null,"sudo nginx -t")),"\n",l.createElement(n.li,null,'Nginx가 설정 파일을 다시 읽고 적용하도록 "리로드"시키는 명령어 ',l.createElement(n.code,null,"sudo systemctl reload nginx"),'\n"nginx야, 새로 바뀐 설정 파일 좀 반영해서 다시 작동해줘~~~"'),"\n"),"\n",l.createElement(n.h1,null,"HTTPS 인증서를 Certbot으로 추가 방법"),"\n",l.createElement(n.p,null,"Nginx 서버 설정에 새로 추가된 서버 도메인 내용에 다음 명령어 실행시 Certbot이 자동으로 채워준다\n= HTTPS(SSL) 적용하고 싶다면 이 도메인에 대해 실제 SSL 인증서를 새로 발급"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"SSL 인증서를 새로 발급\n",l.createElement(n.code,null,"sudo certbot --nginx -d test-service.gwiyeom.org"),"\n-> Congratulations! You have successfully enabled HTTPS on"),"\n"),"\n",l.createElement(n.h3,null,"TIP) 이름 문제 발생?"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"도메인 이름 규칙 (중요)\n도메인 이름은 RFC 표준에 따라 다음 규칙을 따라야 한다:\n✅ 허용: 영문 소문자 (a-z), 숫자 (0-9), 하이픈 (-)\n❌ 금지: 언더스코어(_), 공백, 특수문자\n\ntest_service.gwiyeom.org ← ❌ 잘못된 도메인 이름\n")),"\n",l.createElement(n.h1,null,"(질문)docker 사용시 nginx가 꼭 필요한 건가?"),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"Docker로 단순 개발, 테스트 중\t-> ❌ 필요 없음 (브라우저가 직접 포트로 접근)\n여러 서비스를 운영하거나 도메인 연결할 때 ->  ✅ Nginx 필요!\nHTTPS(SSL) 인증서를 사용하고 싶을 때 -> \t✅ Certbot + Nginx 필요\nReact/Next 같은 프론트도 함께 서빙할 때 -> ✅ Nginx에서 정적 파일 서빙 좋음\n")))}var c=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.RP)(),e.components);return n?l.createElement(n,e,l.createElement(o,e)):o(e)},a=t(7292);function u(e){return l.createElement(a.A,e,l.createElement(c,e))}a.A}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-server-infra-2025-04-12-infra-nginx-mdx-f348bdf87dc37a2cc294.js.map